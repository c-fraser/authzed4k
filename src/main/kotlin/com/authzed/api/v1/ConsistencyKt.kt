//Generated by the protocol buffer compiler. DO NOT EDIT!
// source: authzed/api/v1/permission_service.proto

package com.authzed.api.v1;

@kotlin.jvm.JvmSynthetic
public inline fun consistency(block: com.authzed.api.v1.ConsistencyKt.Dsl.() -> kotlin.Unit): com.authzed.api.v1.PermissionService.Consistency =
  com.authzed.api.v1.ConsistencyKt.Dsl._create(com.authzed.api.v1.PermissionService.Consistency.newBuilder()).apply { block() }._build()
public object ConsistencyKt {
  @kotlin.OptIn(com.google.protobuf.kotlin.OnlyForUseByGeneratedProtoCode::class)
  @com.google.protobuf.kotlin.ProtoDslMarker
  public class Dsl private constructor(
    private val _builder: com.authzed.api.v1.PermissionService.Consistency.Builder
  ) {
    public companion object {
      @kotlin.jvm.JvmSynthetic
      @kotlin.PublishedApi
      internal fun _create(builder: com.authzed.api.v1.PermissionService.Consistency.Builder): Dsl = Dsl(builder)
    }

    @kotlin.jvm.JvmSynthetic
    @kotlin.PublishedApi
    internal fun _build(): com.authzed.api.v1.PermissionService.Consistency = _builder.build()

    /**
     * <pre>
     * minimize_latency indicates that the latency for the call should be
     * minimized by having the system select the fastest snapshot available.
     * </pre>
     *
     * <code>bool minimize_latency = 1 [(.validate.rules) = { ... }</code>
     */
    public var minimizeLatency: kotlin.Boolean
      @JvmName("getMinimizeLatency")
      get() = _builder.getMinimizeLatency()
      @JvmName("setMinimizeLatency")
      set(value) {
        _builder.setMinimizeLatency(value)
      }
    /**
     * <pre>
     * minimize_latency indicates that the latency for the call should be
     * minimized by having the system select the fastest snapshot available.
     * </pre>
     *
     * <code>bool minimize_latency = 1 [(.validate.rules) = { ... }</code>
     */
    public fun clearMinimizeLatency() {
      _builder.clearMinimizeLatency()
    }
    /**
     * <pre>
     * minimize_latency indicates that the latency for the call should be
     * minimized by having the system select the fastest snapshot available.
     * </pre>
     *
     * <code>bool minimize_latency = 1 [(.validate.rules) = { ... }</code>
     * @return Whether the minimizeLatency field is set.
     */
    public fun hasMinimizeLatency(): kotlin.Boolean {
      return _builder.hasMinimizeLatency()
    }

    /**
     * <pre>
     * at_least_as_fresh indicates that all data used in the API call must be
     * *at least as fresh* as that found in the ZedToken; more recent data might
     * be used if available or faster.
     * </pre>
     *
     * <code>.authzed.api.v1.ZedToken at_least_as_fresh = 2;</code>
     */
    public var atLeastAsFresh: com.authzed.api.v1.Core.ZedToken
      @JvmName("getAtLeastAsFresh")
      get() = _builder.getAtLeastAsFresh()
      @JvmName("setAtLeastAsFresh")
      set(value) {
        _builder.setAtLeastAsFresh(value)
      }
    /**
     * <pre>
     * at_least_as_fresh indicates that all data used in the API call must be
     * *at least as fresh* as that found in the ZedToken; more recent data might
     * be used if available or faster.
     * </pre>
     *
     * <code>.authzed.api.v1.ZedToken at_least_as_fresh = 2;</code>
     */
    public fun clearAtLeastAsFresh() {
      _builder.clearAtLeastAsFresh()
    }
    /**
     * <pre>
     * at_least_as_fresh indicates that all data used in the API call must be
     * *at least as fresh* as that found in the ZedToken; more recent data might
     * be used if available or faster.
     * </pre>
     *
     * <code>.authzed.api.v1.ZedToken at_least_as_fresh = 2;</code>
     * @return Whether the atLeastAsFresh field is set.
     */
    public fun hasAtLeastAsFresh(): kotlin.Boolean {
      return _builder.hasAtLeastAsFresh()
    }

    /**
     * <pre>
     * at_exact_snapshot indicates that all data used in the API call must be
     * *at the given* snapshot in time; if the snapshot is no longer available,
     * an error will be returned to the caller.
     * </pre>
     *
     * <code>.authzed.api.v1.ZedToken at_exact_snapshot = 3;</code>
     */
    public var atExactSnapshot: com.authzed.api.v1.Core.ZedToken
      @JvmName("getAtExactSnapshot")
      get() = _builder.getAtExactSnapshot()
      @JvmName("setAtExactSnapshot")
      set(value) {
        _builder.setAtExactSnapshot(value)
      }
    /**
     * <pre>
     * at_exact_snapshot indicates that all data used in the API call must be
     * *at the given* snapshot in time; if the snapshot is no longer available,
     * an error will be returned to the caller.
     * </pre>
     *
     * <code>.authzed.api.v1.ZedToken at_exact_snapshot = 3;</code>
     */
    public fun clearAtExactSnapshot() {
      _builder.clearAtExactSnapshot()
    }
    /**
     * <pre>
     * at_exact_snapshot indicates that all data used in the API call must be
     * *at the given* snapshot in time; if the snapshot is no longer available,
     * an error will be returned to the caller.
     * </pre>
     *
     * <code>.authzed.api.v1.ZedToken at_exact_snapshot = 3;</code>
     * @return Whether the atExactSnapshot field is set.
     */
    public fun hasAtExactSnapshot(): kotlin.Boolean {
      return _builder.hasAtExactSnapshot()
    }

    /**
     * <pre>
     * fully_consistent indicates that all data used in the API call *must* be
     * at the most recent snapshot found.
     * NOTE: using this method can be *quite slow*, so unless there is a need to
     * do so, it is recommended to use `at_least_as_fresh` with a stored
     * ZedToken.
     * </pre>
     *
     * <code>bool fully_consistent = 4 [(.validate.rules) = { ... }</code>
     */
    public var fullyConsistent: kotlin.Boolean
      @JvmName("getFullyConsistent")
      get() = _builder.getFullyConsistent()
      @JvmName("setFullyConsistent")
      set(value) {
        _builder.setFullyConsistent(value)
      }
    /**
     * <pre>
     * fully_consistent indicates that all data used in the API call *must* be
     * at the most recent snapshot found.
     * NOTE: using this method can be *quite slow*, so unless there is a need to
     * do so, it is recommended to use `at_least_as_fresh` with a stored
     * ZedToken.
     * </pre>
     *
     * <code>bool fully_consistent = 4 [(.validate.rules) = { ... }</code>
     */
    public fun clearFullyConsistent() {
      _builder.clearFullyConsistent()
    }
    /**
     * <pre>
     * fully_consistent indicates that all data used in the API call *must* be
     * at the most recent snapshot found.
     * NOTE: using this method can be *quite slow*, so unless there is a need to
     * do so, it is recommended to use `at_least_as_fresh` with a stored
     * ZedToken.
     * </pre>
     *
     * <code>bool fully_consistent = 4 [(.validate.rules) = { ... }</code>
     * @return Whether the fullyConsistent field is set.
     */
    public fun hasFullyConsistent(): kotlin.Boolean {
      return _builder.hasFullyConsistent()
    }
    public val requirementCase: com.authzed.api.v1.PermissionService.Consistency.RequirementCase
      @JvmName("getRequirementCase")
      get() = _builder.getRequirementCase()

    public fun clearRequirement() {
      _builder.clearRequirement()
    }
  }
}
@kotlin.jvm.JvmSynthetic
public inline fun com.authzed.api.v1.PermissionService.Consistency.copy(block: com.authzed.api.v1.ConsistencyKt.Dsl.() -> kotlin.Unit): com.authzed.api.v1.PermissionService.Consistency =
  com.authzed.api.v1.ConsistencyKt.Dsl._create(this.toBuilder()).apply { block() }._build()
